<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0063)http://web.cs.ucla.edu/classes/fall23/cs31/Projects/3/spec.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
 <title>CS 31 Project 3, Fall 2023</title>
</head>
<body>
<div align="right">
Fall 2023 CS 31
</div>
<div align="center">
<h2>Programming Assignment 3<br>
Picture Perfect</h2>
<p>
<strong>Time due: 11:00 PM, Wednesday, November 1</strong>
</p>
</div>
<!--
<p style="font-size: 90%">
Before you ask a question about this specification, see if it has already been
addressed by the <a href="faq.html">Project 3 FAQ</a>.  And read the FAQ before
you turn in this project, to be sure you didn't misinterpret anything.
</p>
-->
<h3>Introduction</h3>
<p>
You have been hired by Retro Images to write a program allowing an artist
to draw lines to produce amazing computer graphics.  The software works by
having the artist type a series of drawing commands that dictate what lines
it should plot on the screen.  (Retro Images thinks having the artists use
a retro user interface will enhance their creativity.)
</p><p>
The display grid of the system is comprised of "pixels" (pixel stands for
"picture element").  If the grid is 20 pixels high by 30 pixels wide, the
pixel in the upper left corner of the grid is considered to be at row 1,
column 1, and the pixel in the bottom right corner of the grid is at row 20,
column 30.  This image shows such a grid and illustrates several coordinates:
</p>
<pre>                  111111111122222222223
         123456789012345678901234567890
        +------------------------------+
       1|A                            C|    A is at (1,1)
       2|  B                           |    B is at (2,3)
       3|                              |    C is at (1,30)
       4|                              |    D is at (7,11)
       5|                              |    E is at (19,28)
       6|                              |    F is at (20,1)
       7|          D                   |    G is at (20,30)
       8|                              |
       9|                              |
      10|                              |
      11|                              |
      12|                              |
      13|                              |
      14|                              |
      15|                              |
      16|                              |
      17|                              |
      18|                              |
      19|                           E  |
      20|F                            G|
        +------------------------------+
</pre>
<p>
The program you will eventually write will allow a user to type a series of
drawing commands and see the results in the display grid.  We know that
this may be the most complex program that many of you will have written in
your programming careers to date, so rather than our just detailing the
visible behavior of the program in this spec and leaving you to come up with
a program design, we will make it easier for you by decomposing the problem
for you.  We will specify some functions that you must implement in your
solution.  In addition to testing your program as a whole, we will also
test each of those functions separately.  That way, if your program
doesn't work overall but you correctly implemented some of the functions,
you'll earn some credit.
</p><p>
You'll work on this program in three phases:
</p>
<ol>
<li>Learn how to build a multifile project and to use the little graphics
library that we've provided to help you with this project.</li>
<li>Write a function to plot a line in the display grid.</li>
<li>Write a function that takes a drawing command string and calls the
line plotting function appropriately.</li>
</ol>
<h3>Phase 1:  Learn how to use the graphics library</h3>
<p>
Do the <a href="http://web.cs.ucla.edu/classes/fall23/cs31/Projects/3/phase1.html">Project 3 phase 1</a> to learn how to build a
multifile program and use the graphics library.  Make sure you can build
and run your program under both g31 and either Visual C++ or clang++.
</p>
<h3>Phase 2:  Write the line plotting function</h3>
<p>
You <strong>must</strong> implement the <code>plotLine</code> function
described below, using the exact function name, parameters types, and return
type shown in this specification.  (The parameter <em>names</em> may be
different if you wish.)  The function must not use any global variables other
than the four constants <code>HORIZ</code>, <code>VERT</code>,
<code>BG</code>, and <code>FG</code> defined below.  In addition to testing
your program as a whole, we will also test this line plotting function
function separately.  That way, if your program doesn't work overall but you
correctly implemented this function, you'll still get some credit.  All of
the code you write must be in the file <code>picture.cpp</code>.
</p><p>
You may write functions in addition to the one listed here.  While we won't
test those additional functions separately, their use may help you
structure your program more readably and avoid duplicating code.
</p><p>
This function must not cause anything to be written to <code>cout</code>.
(Thus, it doesn't call the <code>draw</code> function.)  Your function may,
however, use the <code>setChar</code> function from the graphics library
to plot characters in the grid.  Your function might be called with a
specification of a line that doesn't lie entirely in the grid.  In that
case it must not plot any characters of that line, and certainly should
never ask <code>setChar</code> to plot a character outside the grid, since
attempting to do so causes <code>setChar</code> to terminate the program.
</p><p>
Here is the function you must implement:
</p>
<pre>const int HORIZ = 0;
const int VERT = 1;

const int FG = 0;
const int BG = 1;

bool plotLine(int r, int c, int distance, int dir, char plotChar, int fgbg);
</pre>
<p>
This function sets characters in the grid to form a line segment, one of whose
endpoints is (r,c).  The <code>dir</code> parameter should be either
<code>HORIZ</code>, indicating a horizontal line, or <code>VERT</code>,
indicating a vertical line.  If the <code>distance</code> parameter is
positive, the line extends rightward or downward from (r,c), depending on
whether the line is horizontal or vertical, respectively; if
<code>distance</code> is negative, the line extends leftward or upward from
(r,c); if <code>distance</code> is zero, the "line" consists only of the
point (r,c).  The absolute value of <code>distance</code> is the distance from
(r,c) to the other endpoint of the line.
</p><p>
The <code>plotChar</code> parameter is the character used to form the line.
The <code>fgbg</code> parameter should be either <code>FG</code> or
<code>BG</code>.  The value <code>FG</code> indicates that the line should be
plotted in the foreground:  At every position in the line, the plot character
replaces whatever character is in the grid at that point.  The value
<code>BG</code> indicates the line is to be plotted in the background:  At
every position in the line, if the character in the grid at that point is
a space character (<code>' '</code>), then the plot character replaces it;
otherwise, the character at that position is left unchanged.
</p><p>
The function returns <code>true</code> if it succeeds, and <code>false</code>
otherwise.  The function succeeds if and only if all of these conditions hold:
</p>
<ul>
<li>
The <code>dir</code> value is either <code>HORIZ</code> or <code>VERT</code>
(i.e., either 0 or 1).
</li><li>
The <code>fgbg</code> value is either <code>FG</code> or <code>BG</code>
(i.e., either 0 or 1).
</li><li>
Every position of the line to be plotted must be within the grid.
</li><li>
The <code>plotChar</code> must be a character for which the library function
<code>isprint</code> returns a value that tests as true (i.e.  <code>if
(isprint(<em>that character</em>))</code> would select the true branch of
the if statement).  <code>isprint</code> is declared in the header
<code>&lt;cctype&gt;</code>, and returns an integer that tests as true for
any "printable" character (letters, digits, punctuation, and the space
character), and an integer that tests as false for any other character.
</li>
</ul>
<p>
If the function does not succeed (i.e., at least one of the above conditions
doesn't hold), then it must not modify any characters in the grid.
</p><p>
Here is an example:
</p>
<pre>    setSize(20, 15);  // grid has 20 rows, 15 columns
    if ( ! plotLine(14, 8, 3, HORIZ, '*', FG))   // first call
       cout &lt;&lt; "1) Plotting failed when it shouldn't have!" &lt;&lt; endl;
    if ( ! plotLine(15, 10, -2, VERT, '@', FG))  // second call
       cout &lt;&lt; "2) Plotting failed when it shouldn't have!" &lt;&lt; endl;
    if ( ! plotLine(13, 8, 3, HORIZ, '#', BG))   // third call
       cout &lt;&lt; "3) Plotting failed when it shouldn't have!" &lt;&lt; endl;
    if (plotLine(13, 14, 3, HORIZ, 'X', FG))     // fourth call
       cout &lt;&lt; "4) Plotting succeeded when it shouldn't have!" &lt;&lt; endl;
    draw();
</pre>
<p>
The first call sets grid positions (14, 8), (14, 9), (14, 10), and (14, 11)
to <code>*</code> characters.  Since the function returns true, the first
failure message is not printed.
</p><p>
The second call sets grid positions (15, 10), (14, 10), and (13, 10) to
<code>@</code> characters.  Since the function returns true, the second
failure message is not printed.  Notice that the <code>*</code> character
at (14, 10) is replaced by the <code>@</code> because of the <code>FG</code>
parameter.
</p><p>
The third call sets grid positions (13, 8), (13, 9), and (13, 11) to
<code>#</code> characters.  Since the function returns true, the third
failure message is not printed.  Notice that the <code>@</code> character
at (13, 10) is not replaced by the <code>#</code> because of the
<code>BG</code> parameter.  The characters at the other coordinates of the
line were space characters, so they were replaced.
</p><p>
The fourth call does not change anything in the grid, because it's asking to
set (13, 14), (13, 15), (13, 16), and (13, 17), the last two of which lie
outside the grid.  Since the function returns false, the fourth message is not
printed.
</p><p>
Here's another example, one that uses the <code>assert</code> facility of the
standard C++ library.  If you #include the header <code>&lt;cassert&gt;</code>
you can call <code>assert</code> in the following manner:
</p>
<pre>    assert(<em>some boolean expression</em>);
</pre>
<p>
During execution, if the expression is true, nothing happens and execution
continues normally; if it is false, a diagnostic message is written
telling you the text and location of the failed assertion, and the program
is terminated.  Here is the example:
</p>
<pre>    setSize(2, 12);  // 2 rows, 12 columns
    assert(plotLine(1, 1, 0, HORIZ, 'H', FG));
    assert(plotLine(1, 2, 0, HORIZ, 'i', FG));
    assert(plotLine(1, 3, 0, HORIZ, '!', FG));
    draw();  //  displays  Hi!  in the top row of the grid
    assert(plotLine(1, 3, 0, HORIZ, ' ', FG));
    draw();  //  displays  Hi   in the top row of the grid
    assert(plotLine(1, 1, 10, HORIZ, ' ', BG));
    draw();  //  displays  Hi   in the top row of the grid
    assert( ! plotLine(1, 1, 10, HORIZ, '\n', FG));
    draw();  //  displays  Hi   in the top row of the grid
</pre>
<p>
Writing space characters in the foreground replace characters with spaces.
Writing space characters in the background has no visible effect:  Non-space
characters are unchanged, and space characters are replaced by space
characters, which doesn't effectively change them either.  The last assertion
asserts that calling <code>plotLine</code> with a newline character
returns false (since newline is not a character for which
<code>isprint</code> returns a value that tests as true), and the final
call to <code>draw</code> shows that no grid characters were changed as a
result of that last call to <code>plotLine</code>.
</p>
<h3>Phase 3:  Write the command string interpreter</h3>
<p>
One possible final version of the program will set a grid size and then
repeatedly:
</p>
<ol>
<li><p>
Prompt the user for a <em>command string</em>, which is a line of text
containing a sequence of <em>plotting commands</em>.
</p></li><li><p>
Read a command string.
</p></li><li><p>
If the command string is the empty string, terminate the program.  Otherwise,
for each plotting command in the command string, perform the action specified
by that plotting command.
</p></li><li><p>
After all the plotting commands in the command string have been performed,
draw the resulting grid.
</p></li>
</ol>
<p>
Imagine a
<a href="http://www.amazon.com/BIC-4-Color-Point-Twelve-MMXP11/dp/B000R30PMS" target="_blank">multicolor pen</a> that you can use to draw lines, except
that instead depositing inks of different colors onto paper as you move
it, it places characters in a grid as you move it.  Just as a real pen at
any particular time has a color that it's set to and a position on the
paper, we will consider our virtual pen to have a <em>current
character</em> that it plots with, a <em>current mode</em> (either
foreground mode or background mode), and a <em>current position</em> in
the grid.
</p><p>
When the program starts, the current character is <code>*</code> and the
current mode is foreground mode.  This can be changed by a plotting
command described below.  For each command string, the current position is
set to row 1, column 1 of the grid, and then the plotting commands in the
command string are performed.  Plotting commands in the command string
will cause the current position to change as the virtual pen moves as it
plots draw lines.
</p>
<p>
Suppose the grid size has been set to 8 rows and 20 columns.  Here is an
example of a command string, one that contains five plotting commands:
</p>
<pre>    h12V3H-1B@v-3
</pre>
<p>
Each plotting command starts with a single letter indicating the action to
perform (e.g, <code>H</code> or <code>h</code> to draw a horizontal line).
(The action is the same whether the letter is upper or lower case.)  Following
the letter is the argument to that command.  (The argument for each
command is described later.)  Arguments that are numbers are written with
a possible minus sign character (<code>-</code>) followed by exactly one or
two digits.  The command string above contains the five plotting commands:
</p>
<pre>    h12
    V3
    H-1
    B@
    v-3
</pre>
<p>
The first plotting command above consists of the letter <code>h</code> and
the argument 12, which represents a distance.  Starting from the current
position, initially (1, 1), it plots a horizontal line of the current
character, initially <code>*</code>, in the current mode, initially
foreground mode.  Because the argument is positive, the line is plotted in
the rightward direction.  The line ends 12 positions to the right of where it
started, and that becomes the new current position.  So the effect of this
plotting command is to set positions (1, 1), (1, 2), (1, 3), ..., (1, 12),
and (1, 13) of the grid to <code>*</code> and the current position to
(1, 13).  
</p><p>
The second plotting command above consists of the letter <code>V</code> and
the argument 3, which represents a distance.  Starting from the current
position, (1, 13), this plots a vertical line of <code>*</code> downward. 
The effect of this plotting command is to set positions (1, 13), (2, 13), (3,
13), and (4, 13) of the grid to <code>*</code> and the current position to
(4, 13).
</p><p>
The third plotting command above consists of the letter <code>H</code> and
the argument -1, which represents a distance; for a horizontal line, this
would mean a distance of 1 in the leftward direction.  Starting from the
current position, (4, 13), this plots a horizontal line of <code>*</code>
leftward.  The effect of this plotting command is to set positions (4, 13)
and (4, 12) of the grid to <code>*</code> and the current position to
(4, 12).
</p><p>
The fourth plotting command above consists of the letter <code>B</code> and
the argument <code>@</code>, which is what we want the new current character
to be.  This plotting command does not plot any characters or change the
current position.  Instead, it changes the current mode to background mode
and the current character to <code>@</code>.
</p><p>
The fifth plotting command above consists of the letter <code>v</code> and
the argument -3, which represents a distance; for a vertical line, this would
mean a distance of 3 in the upward direction.  Starting from the current
position, (4, 12), this plots a vertical line of <code>@</code>, the current
character, upward in background mode, the current mode.  In background mode,
only space characters in the grid are replaced by the current character.  The
effect of this command is to leave position (4, 12) unchanged (since it
contains a <code>*</code>), set (3, 12) and (2, 12) to <code>@</code> (since
they contain spaces), and leave (1, 12) unchanged (since it contains a
<code>*</code> placed there by the first plotting command).  The current
position is now (1, 12); the virtual pen is there even though the character
there was unchanged.
</p><p>
After all the plotting commands in the command string above are performed,
the grid is drawn, showing this on the screen:
</p>
<pre>                  11111111112
         12345678901234567890
        +--------------------+
       1|*************       |
       2|           @*       |
       3|           @*       |
       4|           **       |
       5|                    |
       6|                    |
       7|                    |
       8|                    |
        +--------------------+
</pre>
<p>
Suppose the next command string the user enters is
</p>
<pre>    v2b h12fHh1fih0
</pre>
<p>
The current character is still <code>@</code> and the current mode is still
background mode; those always carry over from the previous command string.
However, at the start of every command string, the current position is
(1, 1).
</p><p>
The seven plotting commands in this command string and their effects are
</p>
<pre>    v2
    b      <em>(the </em>b is followed by a space character)
    h12
    fH
    h1
    fi
    h0
</pre>
<p>
The <code>v2</code> leaves (1, 1) unchanged, since we're still in background
mode, and sets (2, 1) and (3, 1) to the current character, <code>@</code>,
making the current position (3, 1).  The second command puts us in
background mode with the space character as the current character, and the
third command makes the current position (3, 13).  Notice that setting the
current character to a space character in background mode lets you move
the virtual pen without changing any characters in the grid, rather like
lifting a real pen off the paper to move it without drawing anything.
</p><p>
The <code>fH</code> puts us in foreground mode with <code>H</code> as the
current character, and the <code>h1</code> puts the <code>H</code> in
(3, 13) and (3, 14); we overwrite the second one when the <code>fi</code>
sets the current character to <code>i</code> and the <code>h0</code> sets
(3, 14) to <code>i</code>, leaving the current position as (3, 14).  After
it performs the plotting commands in the command string, the program draws
the grid, showing
</p><p>
</p><pre>                  11111111112
         12345678901234567890
        +--------------------+
       1|*************       |
       2|@          @*       |
       3|@          @Hi      |
       4|           **       |
       5|                    |
       6|                    |
       7|                    |
       8|                    |
        +--------------------+
</pre>
<p></p>
If the next command string the user enters is
<p></p>
<pre>    CV6
</pre>
<p>
the program interprets it as consisting of the two plotting commands
</p>
<pre>    C
    V6
</pre>
<p>
The <code>C</code> command clears the entire grid (resulting in every
character of the grid being a space character) and sets the current
position to (1, 1), the current character to <code>*</code>, and the
current mode to foreground mode.  The <code>V6</code> plots a vertical
line.  The grid is then drawn, showing
</p>
<pre>                  11111111112
         12345678901234567890
        +--------------------+
       1|*                   |
       2|*                   |
       3|*                   |
       4|*                   |
       5|*                   |
       6|*                   |
       7|*                   |
       8|                    |
        +--------------------+
</pre>
<h3>Syntax for the plotting commands</h3>
<p>
A command string is a sequence of one or more plotting commands.  There must
be no characters between its component plotting commands, and plotting
commands must not contain any characters other than those specified by the
definition of their syntax below.  For example, <code>H25H-10</code> is a
valid command string, but these are not:
</p>
<pre>    H25,H-10     <em>(Comma not allowed between plotting commands.)</em>
    H25 H-10     <em>(Space not allowed between plotting commands.)</em>
    H+25H-10     <em>(Plus not allowed in </em>H<em> command.)</em>
</pre>
<h3>List of required plotting commands</h3>
<p>
Your program must support the plotting commands listed below.
</p>
<h4>Horizontal Line command</h4>
<p>
This command consists of an upper or lower case <code>H</code> immediately
followed by an argument in one of the following forms:
</p>
<ul>
<li>
one digit character
</li><li>
two digit characters
</li><li>
a minus sign followed by one digit character
</li><li>
a minus sign followed by two digit characters
</li>
</ul>
<p>
This command sets characters in the grid to form a horizontal line segment, one
of whose endpoints is the current position.  If the command does not contain
a minus sign, the line extends rightward from the current position; if the
command contains a minus sign, the line extends leftward.  The one or two
digits in the command indicate the distance from the current position to the
other endpoint of the line.  Notice that the plotting commands
<code>H3</code> and <code>H03</code> have the same effect.  If the one or
two digits are <code>0</code> or <code>00</code>, the "line" consists only
of the current position.
</p><p>
If the current mode is foreground mode, the character in the grid at every
position in the line is replaced by the current character.  If the current
mode is background mode, only the space characters in the grid that are at
positions in the line are replaced by the current character.  After this
plotting command is performed, the current position is the position of the
other endpoint of the line; unless the digits in the command were
<code>0</code> or <code>00</code>, this will be a different position from what
it was before performing the command.
</p><p>
If performing this command would attempt to plot a character outside the
grid, then this command must not modify any characters in the grid and
must not change the current position.  For example, if the grid has 20
columns and the current position is (13, 19), you would not plot any
characters for the plotting command <code>H3</code>, and the current position
would remain (13, 19).  Notice that the command <code>H76</code> is a
syntactically valid plotting command, but performing this command could
never result in any characters being plotted, since <code>setSize</code>
does not allow you to create a grid with more than <code>MAXCOLS</code>
(30) columns.
</p>
<h4>Vertical Line command</h4>
<p>
This command consists of an upper or lower case <code>V</code> immediately
followed by an argument in one of the same four forms as for the <code>H</code>
command.
</p>

<p>
This command sets characters in the grid to form a vertical line segment, one
of whose endpoints is the current position.  If the command does not contain
a minus sign, the line extends downward from the current position; if the
command contains a minus sign, the line extends upward.  The one or two
digits in the command indicate the distance from the current position to the
other endpoint of the line.  Notice that the plotting commands
<code>V3</code> and <code>V03</code> have the same effect.  If the one or
two digits are <code>0</code> or <code>00</code>, the "line" consists only
of the current position.
</p><p>
If the current mode is foreground mode, the character in the grid at every
position in the line is replaced by the current character.  If the current
mode is background mode, only the space characters in the grid that are at
positions in the line are replaced by the current character.  After this
plotting command is performed, the current position is the position of the
other endpoint of the line; unless the digits in the command were
<code>0</code> or <code>00</code>, this will be a different position from what
it was before performing the command.
</p><p>
If performing this command would attempt to plot a character outside the
grid, then this command must not modify any characters in the grid and
must not change the current position.  For example, if the grid has 20 rows
and the current position is (13, 19), you would not plot any characters for
the plotting command <code>V8</code>, and the current position would remain
(13, 19).  Notice that the command <code>V76</code> is a syntactically valid
plotting command, but performing this command could never result in any
characters being plotted, since <code>setSize</code> does not allow you to
create a grid with more than <code>MAXROWS</code> (30) rows.
</p>
<h4>Foreground command</h4>
<p>
This command consists of an upper or lower case <code>F</code> immediately
followed by one character.  That character must be one for which the library
function <code>isprint</code> returns a value that tests as true.
</p><p>
Executing this command sets the mode to foreground mode and the current
character to the character that follows the upper or lower case <code>F</code>.
</p>
<h4>Background command</h4>
<p>
This command consists of an upper or lower case <code>B</code> immediately
followed by one character.  That character must be one for which the library
function <code>isprint</code> returns a value that tests as true.
</p><p>
Executing this command sets the mode to background mode and the current
character to the character that follows the upper or lower case <code>B</code>.
</p>
<h4>Clear command</h4>
<p>
This command consists of an upper or lower case <code>C</code>.
</p>
<p>
This command sets every character of the grid to be a space character and
sets the current position to (1, 1), the current character to
<code>*</code>, and the current mode to foreground mode.
</p>
<h3>The <code>performCommands</code> function</h3>
<p>
You must implement this function:
</p>
<pre>    int performCommands(string commandString, char&amp; plotChar, int&amp; mode, int&amp; badPos)
</pre>
<p>
If <code>plotChar</code> is a non-printable character (i.e., one for which
<code>isprint</code> returns a value that tests as false) or if
<code>mode</code> does not have the value <code>FG</code> or <code>BG</code>,
this function returns 2 without changing anything.  The rest of this
description of <code>performCommands</code> applies when the function is
called with <code>plotChar</code> being a printable character and
<code>mode</code> having the value <code>FG</code> or <code>BG</code>.
</p>
<p>
This function starts by setting the current position to (1, 1), the current
character to <code>plotChar</code>, and the current mode to
<code>mode</code>.  It then parses <code>commandString</code>, performing the
indicated plotting commands (e.g., by calling the <code>plotLine</code>
function described in Phase 2 to plot lines).  If <code>commandString</code>
is a syntactically valid command string and all plotting commands are
performed successfully, this function returns 0 when the plotting actions are
completed and does not modify the <code>badPos</code> parameter;
<code>plotChar</code> will be the (possibly changed) current character and
<code>mode</code> will be the (possibly changed) current mode resulting from
performing the commands.  (Note:  The empty string is a syntactically valid
command string, and performing it performs zero plotting actions, all zero of
them successfully.) 
</p><p></p>
Here are some examples of errors that would cause <code>commandString</code>
to be syntactically invalid:
<p></p>
<ul>
<li>
Where a plotting command is expected to begin, a character that is not a
valid command letter appears, e.g., <code>Q</code> or <code>6</code> or
<code>%</code> instead of <code>H</code>, <code>h</code>, <code>V</code>,
<code>v</code>, etc.  
</li><li>
Extra characters appear, such as a space between a plotting command letter
<code>H</code> and its numeric argument.
</li><li>
Missing or extra arguments.
</li><li>
A numeric argument that does not have exactly one or two digits.
</li><li>
A non-printable character as the argument to the <code>F</code> or
<code>B</code> command.
</li>
</ul>
<p></p><p></p>
If the command string is syntactically invalid, this function returns 1 after
setting <code>badPos</code> to the position in the string of the leftmost
syntax error, considering 0 to be the position of the first character of the
command string.  (If the error occurs because the command string ends but a
character is expected, the position number will be the length of the string.)
Here are some examples:
<p></p>
<pre>F#H+25H?V3! sets badPos to 3   <em>leftmost syntax error</em>
B@H         sets badPos to 3   <em>expecting - or digit after H</em>
C12         sets badPos to 1   <em>C is one command; 1 can't start a command</em>
Q3V4#       sets badPos to 0   <em>Q can't start a command</em>
V03C H123#  sets badPos to 4   <em>space can't start a command</em>
H18H-123#   sets badPos to 7   <em>H-12 is one command; 3 can't start a command</em>
H5H-1-2     sets badPos to 5   <em>H-1 is one command; - can't start a command</em>
FH8         sets badPos to 2   <em>FH is one command; 8 can't start a command</em>
</pre>
<p>
If the command string is syntactically valid, but performing a plotting
command would attempt to plot a character outside the grid, this function
returns 3 after setting <code>badPos</code> to the position in the string
of the letter that starts the earliest occurring plotting command that would
make this attempt, considering 0 to be the position of the first character of
the command string.  For example, for a grid with 20 rows and 30 columns, the
command string <code>H28V10H5V86</code> would cause this function to return 3
after setting <code>badPos</code> to 6, because when the current position is
(11, 29), the <code>H5</code> would not succeed, and the position of that
<code>H</code> is 6.  Notice that the <code>V86</code> plotting command in
that string is syntactically valid, but would also not succeed; the function
does not set <code>badPos</code> to 8, the position of that <code>V</code>,
since that is not the earliest occurring unsuccessful plotting command. 
Notice also that for the command string <code>V86F</code> the function must
set <code>badPos</code> to 4 and return 1, since the command string does not
have valid syntax; problematic performances are indicated only for
syntactically valid strings.  
</p><p>
In the situations where this function must return 1 (syntax error) or 3
(attempt to plot off-grid), it is your choice as to whether or
not the plotting commands preceding the point of error are performed, and
whether or not <code>plotChar</code> and <code>mode</code> are modified by
those preceding plotting commands.
</p><p>
You may write additional functions that <code>performCommands</code> calls to
help it do its job.  While we won't test those additional functions
separately, their use might help you structure <code>performCommands</code>
more readably and avoid duplicating code.
</p><p>
Neither the <code>performCommands</code> function nor any functions it calls
may use any global variables whose values may be changed during execution.
Global <em>constants</em>, like <code>MAXROWS</code> and <code>HORIZ</code>,
are fine.
</p><p>
The <code>performCommands</code> function must not cause <code>setChar</code>
to be called except as a result of <code>plotLine</code> being called.  In
other words, <code>performCommands</code> uses only <code>plotLine</code> to
do any character plotting; it must not bypass <code>plotLine</code> and try to
plot characters by calling <code>setChar</code> directly.  The
<code>performCommands</code> function must not cause anything to be written
to <code>cout</code>; thus, it must not call the <code>draw</code> function.
</p><p>
The <code>performCommands</code> function must <em>not</em> assume that
<code>badPos</code> has any particular value (such as 0 or 42 or -123) at
the time this function is entered.  
</p>
<h4>The main routine</h4>
<p>
One possible main routine you can use is this:
</p>
<pre>int main()
{
    for (;;)
    {
        cout &lt;&lt; "Enter the number of grid rows and columns (max 30 each): ";
        int nRows;
        int nCols;
        cin &gt;&gt; nRows &gt;&gt; nCols;
        cin.ignore(10000, '\n');
        if (nRows &gt;= 1  &amp;&amp;  nRows &lt;= MAXROWS  &amp;&amp;  nCols &gt;= 1  &amp;&amp;  nCols &lt;= MAXCOLS)
        {
            setSize(nRows, nCols);
            break;
        }
        cout &lt;&lt; "The numbers must be between 1 and 30." &lt;&lt; endl;
    }
    char currentChar = '*';
    int currentMode = FG;
    for (;;)
    {
        cout &lt;&lt; "Enter a command string (empty line to quit): ";
        string cmd;
        getline(cin, cmd);
        if (cmd == "")
            break;
        int position;
        int status = performCommands(cmd, currentChar, currentMode, position);
        switch (status)
        {
          case 0:
            draw();
            break;
          case 1:
            cout &lt;&lt; "Syntax error at position " &lt;&lt; position &lt;&lt; endl;
            break;
          case 2:
            if (!isprint(currentChar))
                cout &lt;&lt; "Current character is not printable" &lt;&lt; endl;
            if (currentMode != FG  &amp;&amp;  currentMode != BG)
                cout &lt;&lt; "Current mode is " &lt;&lt; currentMode &lt;&lt; ", not FG or BG" &lt;&lt; endl;
            break;
          case 3:
            cout &lt;&lt; "Cannot perform command at position " &lt;&lt; position &lt;&lt; endl;
            break;
          default:
              // It should be impossible to get here.
            cout &lt;&lt; "performCommands returned " &lt;&lt; status &lt;&lt; "!" &lt;&lt; endl;
        }
    }
}
</pre>
<p>
You may use whatever main routine you want during development to test the
required <code>plotLine</code> and <code>perFormCommands</code> functions.
During the course of developing your solution, you might change that main
routine many times.  As long as your main routine compiles correctly when you
turn in your solution, it doesn't matter what it does, even if it does
nothing, since we will rename it to something harmless and never call it
(because we will supply our own main routine to thoroughly test your
functions).
</p><p>
Here's a main routine that has a very incomplete set of test cases:
</p>
<pre>    int main()
    {
        setSize(12, 15);
        assert(plotLine(3, 5, 2, HORIZ, '@', FG));
        for (int c = 5; c &lt;= 7; c++)
            assert(getChar(3, c) == '@');
        assert(getChar(3, 8) == ' ');
        clearGrid();
        char pc = '%';
        int m = FG;
        int bad = 999;
          // A successful command string should not change bad
        assert(performCommands("V2", pc, m, bad) == 0  &amp;&amp;  getChar(3, 1) == '%'  &amp;&amp;  bad == 999);
        assert(performCommands("V2H2Q2", pc, m, bad) == 1  &amp;&amp;  bad == 4);
        assert(performCommands("H4V3V-1H-9", pc, m, bad) == 3  &amp;&amp;  bad == 7);
        cout &lt;&lt; "All tests succeeded." &lt;&lt; endl;
    }
</pre>
<p>
The reason for writing one line of output at the end is to ensure that you
can distinguish the situation of all tests succeeding from the case where one
function you're testing silently crashes the program.
</p>
<h3>Programming Guidelines</h3>
<p>
Your program must build successfully under both g31 and either Visual C++
or clang++.  Try to ensure that your functions do something reasonable for
at least a few test cases. That way, you can get some partial credit for a
solution that does not meet the entire specification. 
</p><p>
Your program must not use library facilities for matching regular expressions.
(These ususally involve "regex" somewhere in the name.)  If you don't know
what this paragraph is talking about, then there's nothing for you to worry
about.
</p><p>
Your <code>plotLine</code> and <code>performCommands</code> functions must
not read anything from <code>cin</code>.  Since they must not write anything
to <code>cout</code>, if you want to print things out for debugging purposes,
write to <code>cerr</code> instead of <code>cout</code>.  <code>cerr</code>
is the standard error destination; items written to it by default go to the
screen.  When we test your program, we will cause everything written to
<code>cerr</code> to be discarded instead � we will never see that
output, so you may leave those debugging output statements in your program if
you wish.  (Note that the <code>draw</code> functions write to
<code>cout</code>, not <code>cerr</code>.  If an expression passed to
<code>assert</code> evaluates to false, a diagnostic message is written to
<code>cerr</code>, not <code>cout</code>.)
</p><p>
You must not change the types of the parameters to <code>plotLine</code> and
<code>performCommands</code>.  In particular, you must not change the first
two parameters of <code>plotLine</code> to be of type <code>int&amp;</code>
instead of <code>int</code>.
</p><p>
Except temporarily for your own testing purposes, do not make any changes
whatsoever to the <code>grid.h</code> or <code>grid.cpp</code> files.  You
will turn in only <code>picture.cpp</code>, and we'll use our own versions
of <code>grid.h</code> and <code>grid.cpp</code> when testing your code.
</p><p>
The correctness of your program must not depend on undefined program behavior.
Your program could not, for example, assume anything about <code>c</code>'s
value at the point indicated, or even whether or not the program crashes:
</p>
<pre>    int main()
    {
        string s = "Hello";
        s.at(7) = '!';  // undefined behavior!
        �
</pre>
<p>
Running under g31 may not detect <em>all</em> occurrences of undefined
behavior, but if your program tries to access a bad string position, it
may well tell you what position of what string was the problem.  If you
use <code>s.at(�)</code> instead of <code>s[�]</code>, it
may even tell you on which line of code the problem occurred.
</p>
<h3>Note for Visual C++ users</h3>
<p>
If your program dies under Visual C++ with a dialog box appearing saying
"Debug Assertion Failed! ... File: ...\src\isctype.c ...  expression:
(unsigned)(c+1)&lt;=256", then you called one of the functions defined by
<code>&lt;cctype&gt;</code>, such as <code>isdigit</code> or
<code>isprint</code> or <code>tolower</code>, with a character whose encoding
is outside the range of 0 through 127.  Since all the normal characters you
would use (space, letters, punctuation, etc.) fall inside that range, you're
probably passing an uninitialized character to the function.  Perhaps you're
examining a character at a position past the end or before the beginning of a
string.
</p>
<h3>What to turn in</h3>
<p>
What you will turn in for this assignment is a zip file containing these
two files and nothing more:
</p>
<ol>
<li>
<p>
A text file named <strong>picture.cpp</strong> that contains the source
code for your C++ program.  Your source code should have helpful comments
that tell the purpose of the major program segments and explain any tricky
code.
</p>
</li><li>
A file named <strong>report.docx</strong> (in Microsoft Word format) or
<strong>report.txt</strong> (an ordinary text file) that contains:
<ol style="list-style: lower-alpha">
<li>
A brief description of notable obstacles you overcame.
</li><li>
A description of the design of your program.  You should use
<a href="http://web.cs.ucla.edu/classes/fall23/cs31/pseudocode.html">pseudocode</a> in this description where it
clarifies the presentation.
</li><li>
A list of the test data that could be used to thoroughly test your
program, along with the reason for each test.  You don't have to include
the results of the tests, but you must note which test cases your program
does not handle correctly.  (This could happen if you didn't have time to
write a complete solution, or if you ran out of time while still debugging
a supposedly complete solution.)  If you use the <code>assert</code> style
above for writing your test code, you can copy those <code>assert</code>s,
along with a very brief comment about what it's testing for.  Notice that
most of this portion of your report can be written just after reading the
requirements in this specification, before you even start designing your
program.
</li>
</ol>
</li>
</ol>
<p>
Your zip file must <em>not</em> contain the <code>grid.h</code> and
<code>grid.cpp</code> files that we supply.  When we test your
program, we will use our own versions of these files that we have specially
instrumented for automated testing.
</p>
<p>
By Tuesday, October 31, there will be links on the class webpage that
will enable you
<!--
The <a href="../../Submit/submission.cgi?asst=3">turn in Project 3</a>
link on the class webpage enables you
-->
to turn in your zip file electronically.  Turn in the file by the due time
above.  Give yourself enough time to be sure you can turn something in.
There's a lot to be said for turning in a preliminary version of your program
and report early (You can always overwrite it with a later submission).  That
way you have something submitted in case there's a problem later.
</p>


</body></template></span></div></html>
